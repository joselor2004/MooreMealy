\documentclass{scrartcl}
\usepackage[a4paper, total={7in, 10in}]{geometry}
\usepackage{stmaryrd}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{algorithm2e}
\usepackage{hyperref}
\usepackage[french]{babel}
\usepackage{color}
\usepackage{tikz}
\usetikzlibrary{automata, arrows.meta, positioning}
\usepackage{Macros}

\SetKwProg{Fun}{Function}{ is}{end}

\title{Rapport : Transducteurs et machines de Moore et Mealy}

\begin{document}

\maketitle

\RestyleAlgo{ruled}

\begin{flushleft}

\tableofcontents

\section{Généralités sur les transducteurs finis}

Un transducteur fini est une généralisation des automates finis, implémentant non pas des langages mais plutôt des
relations entre des ensembles de mots. Cela se fait à l'aide d'étiquettes supplémentaires sur chaque transition
entre deux états.

\subsection{Définition des transducteurs}

\begin{define}
    Un transducteur fini est un 6-uplet $T = (\Sigma, \Gamma, Q, I, F, \delta)$ où
    \begin{itemize}
        \item $\Sigma$ est l'alphabet d'entrée (fini)\\
        \item $\Gamma$ l'alphabet de sortie (fini)\\
        \item $Q$ l'ensemble des états (fini)\\
        \item $I \subset Q$ l'ensemble des états initiaux
        \item $F \subset Q$ l'ensemble des états finaux
        \item $\delta : Q \times \Sigma_{\varepsilon} \times \Gamma_{\varepsilon} \longrightarrow \mathcal{P}(Q)$ est
        la fonction de transition non déterministe
    \end{itemize}
\end{define}

En d'autres termes, $T$ est un automate fini non déterministe sur l'alphabet $\Sigma_{\varepsilon} \times \Gamma \cup \Sigma \times \Gamma_{\varepsilon}$
\\~\\
On peut comme pour les automates définir
$\delta^* : Q \times \Sigma^* \times \Gamma^* \longrightarrow \mathcal{P}(Q)$ par induction :
\begin{equation*}
    \begin{split}
        \delta^*_{\mid Q \times \Sigma_{\varepsilon} \times \Gamma_{\varepsilon}} &= \delta\\
        \forall (a, b) \in \Sigma_{\varepsilon} \times \Gamma_{\varepsilon},
        \forall (w, v) \in \Sigma^* \times \Gamma^*, &\forall q \in Q, \delta^*(q, wa, vb) = 
        \bigcup_{p \in \delta^*(q, w, v)} \delta(p, a, b)
    \end{split}
\end{equation*}

On définit ici la relation reconnue par un transducteur fini, de manière similaire que les
langages reconnus par les automates.
\begin{define}
    On défini $[T]$ la relation reconnue par un transducteur fini $T$, définie comme suit :
    \[ \forall (u, v) \in \Sigma^* \times \Gamma^*, u[T]v \Leftrightarrow \exists q \in I, \exists r \in F,
    r \in \delta^*(q, u, v) \]
\end{define}

\begin{figure}[h]
    \caption{Un exemple de transducteur fini reconaissant la relation de congruence modulo 2}
    \begin{center}
    Ici $\Sigma = \Gamma = \{0, 1\}$ et les transitions sont étiquettées par lettre d'entrée, lettre de sortie\\
    \vspace*{0.5cm}
    \begin{tikzpicture}[auto]
        \node (q0) [state, initial, initial text= ] {$q_0$};
        \node (q2) [state, below right = of q0] {$q_2$};
        \node (q1) [state, accepting, above right = of q2] {$q_1$};

        \path [-stealth, thick]
        (q0) edge [loop above] node {$\Sigma_{\varepsilon} \mid \Sigma_{\varepsilon}$} (q0)
        (q0) edge node {$\substack{0 \mid 0 \\ 1 \mid 1}$} (q1)
        (q0) edge [bend right] node {$\substack{0 \mid 1 \\ 1 \mid 0}$} (q2)
        (q1) edge [bend left] node {$\Sigma_{\varepsilon} \mid \Sigma_{\varepsilon}$} (q2)
        (q2) edge [loop below] node {$\Sigma_{\varepsilon} \mid \Sigma_{\varepsilon}$} (q2);
    \end{tikzpicture}
    \end{center}
\end{figure}

\vspace*{2cm}

\subsection{Relations rationnelles}

Soient $\Sigma$ et $\Gamma$ des alphabets finis. Nous allons ici étudier une classe particulière
de relations entre $\Sigma^*$ et $\Gamma^*$, que l'on peut voir comme des parties de $\Sigma^* \times \Gamma^*$,
les relations rationelles. Généralisons pour cela les opérations usuelles sur les langages 

\begin{define}
    Soient $R, R' \subset \Sigma^* \times \Gamma^*$ des relations. On pose
    \begin{itemize}
        \item $R \cdot R' = \{ (xx', yy') \mid (x, y) \in R, (x', y') \in R' \}$, la concaténation ou produit
        \item $\displaystyle R^* = \bigcup_{n \geq 0} R^n$ où $R^n$ est la concaténation répétée, et $R^0 =
        \{ (\varepsilon, \varepsilon) \}$
    \end{itemize}
\end{define}

\begin{define}
    L'ensemble des relations rationelles est défini comme le plus petit ensemble de langages stable par étoile,
    concaténation et union, et contenant $\varnothing$ et les singletons.
\end{define}

Pour être plus général, une relation rationelle est une partie rationnelle du monoïde produit
$\Sigma^* \times \Gamma^*$.\\
Comme pour les automates on a bien équivalence entre les relations reconnues par des transducteurs finis
et les relations rationelles.

\subsection{Propriétés des relations rationnelles et transducteurs finis}

De manière analogue au cas des automates finis et des langages rationnels, on dispose du théorème suivant reliant
les transducteurs finis aux relations rationelles

\begin{theorem}
    Une relation $R$ est rationelle si et seulement si elle est reconnue par un transducteur fini $T$
\end{theorem}

\begin{proof}
    La preuve est exactement du même acabi que celle pour les automates finis et langages rationnels.
\end{proof}

Cette équivalence permet de voir plus simplement certaines propriété de stabilité des transducteurs finis ou des relations
rationnelles.
\begin{prop} \label{stabRat}
    Les relations rationnelles sont stables par inverse. De plus les projections d'une relation
    rationelle sont des langages rationnels.
\end{prop}

\begin{proof}
    Si $R$ est une relation rationelle sur $\Sigma^* \times \Gamma^*$, on note $R^{-1}$ la relation inverse et
    \[ R_{\Sigma} = \{ w \in \Sigma^* \mid \exists u \in \Gamma^*, (w, u) \in R \} \]
    et de même manière $R_{\Gamma}$, les projections à droite et à gauche de $R$. Soit $T$ un transducteur fini reconaissant $R$.\\
    Si l'on considère le transducteur où les étiquettes d'entrée et de sorties sont inversées, ce dernier reconnait bien la
    relation $R^{-1}$.\\
    Si l'on considère l'automate obtenu en ne gardant que les étiquettes d'entrée sur les transitions, cet automate reconnait bien $R_{\Sigma}$.
    On procède de même manière pour $R_{\Gamma}$
\end{proof}

\begin{prop} \label{imageRat}
    Soit $L \subset \Sigma^*$ rationnel. L'image par $R$ une relation rationnelle de $L$ est également régulière
\end{prop}

\begin{proof}
    Soit $\mathcal{A} = (\Sigma, Q_L, I_L, F_L, \delta_L)$ un automate reconaissant $L$. On en fait un transducteur
    $T_L = (\Sigma, \Gamma, Q_L, I_L, F_L, \delta'_L)$ où
    \[ \forall q \in Q_L, \forall a \in \Sigma, \forall b \in \Gamma_{\varepsilon}, \delta'_L(q, a, b) = \delta_L(q, a) \]
    (cela revient à coller $\Gamma_{\varepsilon}$ en étiquette de sortie de chaque transition de $\mathcal{A}$). Si on considère
    maintenant $T_R$ un transducteur fini reconaissant $R$, et que l'on considère le transducteur produit de $T_R$ et $T_L$,
    ayant pour états finaux les produits des états finaux, ce dernier reconait la relation
    \[ R' = \{ (u, v) \in R \mid u \in L \} \]
    En considérant la projection à droite, on obtient alors le langage $R(L) = \{ v \in \Gamma^* \mid \exists u \in L, (u, v) \in R \}$
    qui est bien l'image de $L$ par $R$. Donc par la propriété \ref{stabRat}, $R(L)$ est rationel
\end{proof}

Un exemple d'application de ces propriétés de stabilité est une preuve rapide de la rationnalité de $\operatorname*{Pref}(L)$, l'ensemble des préfixes
d'un langage rationnel $L$ : la relation $\operatorname*{Pref}$ sur $\Sigma^* \times \Sigma^*$ qui met en relation $w$ avec l'ensemble de
ses préfixes est rationnelle, reconnue par le transducteur figure \ref{transPref}. Par la propriété \ref{imageRat}, on obtient immédiatement la rationnalité de 
$\operatorname*{Pref}(L)$

\begin{figure}[h]
    \caption{L'automate reconaissant la relation $\operatorname*{Pref}$ avec $\Sigma = \{a_1, ..., a_n\}$} \label{transPref}
    \begin{center}
    \begin{tikzpicture}[auto]
        \node (q0) [state, initial, initial text= ] {$q_0$};
        \node (q1) [state, accepting, right=of q0] {$q_1$};

        \path[-stealth, thick]
        (q0) edge [loop above] node {$\substack{a_1 \mid a_1 \\ ... \\ a_n \mid a_n}$} (q0)
        (q0) edge node {$\varepsilon \mid \varepsilon$} (q1)
        (q1) edge [loop above] node {$\Sigma \mid \varepsilon$} (q1);
    \end{tikzpicture}
    \end{center}
\end{figure}

\subsection{Quelques problèmes associés aux transducteurs finis}

(Déterminer si un transducteur est fonctionnel, si deux transducteurs implémentent la même relation)

\section{Machines de Moore}

Une machine de Moore est un cas particulier d'un transducteur fini : d'abord une telle machine est déterministe
et implémente donc non pas une relation rationelle mais une fonction, qui sera appelée rationelle. La contrainte
supplémentaire sur ces machines est que la lettre de sortie lue ne dépend que de l'état actuel de l'automate.

\subsection{Définition et exemple}

On peut évidemment définir une machine de Moore en partant de la définition de transducteur et en posant des
contraintes sur la fonction de transition. Il est toutefois plus commode de la définir ainsi

\begin{define}
    Une machine de Moore $\mathcal{M}$ est un $7$-uplet $(\Sigma, \Gamma, Q, q_0, F, \delta, \lambda)$ où
    \begin{itemize}
        \item $\Sigma$ est l'alphabet d'entrée
        \item $\Gamma$ l'alphabet de sortie
        \item $Q$ l'ensemble fini des états
        \item $q_0$ l'état initial
        \item $F \subset Q$ les états finaux
        \item $\delta : Q \times \Sigma \rightarrow Q$ la fonction de transition déterministe
        \item $\lambda : Q \rightarrow \Gamma$ la fonction de sortie
    \end{itemize}
\end{define}

Un calcul de $\mathcal{M}$ sur un mot $w$ est défini de la même manière que pour un automate déterministe. On ajoute
toutefois la notion de mot produit par ce calcul, qui est le mot obtenu en concaténant les lettres obtenues
par application de $\lambda$ sur chaque état pris lors du calcul de $\mathcal{M}$ sur $w$. Plus formellement

\begin{define}
    On définit pour $q \in Q$ et $w \in \Sigma^*$ $q \star w$ récursivement :
    \[ \forall a \in \Sigma, q \star a = \lambda(\delta(q, a)) \text{ et } \forall u \in \Sigma^*,
    q \star ua = (q \star u)(\delta^*(q, u) \star a) \]
    Le mot produit par le calcul de $\mathcal{M}$ sur $w$ est défini comme $q_0 \star w$. Notons $L \subset \Sigma^*$
    le langage reconnu par l'automate déterministe contenu dans la définition de $\mathcal{M}$. La fonction rationelle
    réalisée par $\mathcal{M}$ est alors définie par
    \[ f : \begin{array}{cl}
        L &\longrightarrow \Gamma^*\\
        w &\longmapsto q_0 \star w
    \end{array} \]
\end{define}

On peut généraliser la fonction réalisée par $\mathcal{M}$ en la définissant non pas sur $L$ mais sur tout
$\Sigma^*$. Cela revient à rendre tout les états acceptants

\begin{figure}[h]
    \caption{Un exemple de machine de Moore implémentant le xor chiffre à chiffre entre deux entiers en binaires}
    \begin{center}
        Si l'on souhaite faire le xor de $101$ et $100$, on donne à notre machine l'entrée
        $110010$ et cette dernière renvoie $000001$ (un 0 puis le résultat du xor pour chaque chiffre).
        On ne précise $\lambda(q_0)$ car cette valeur n'est pas utilisée pour définir la fonction de cette machine\\
        \vspace*{0.5cm}
        \begin{tikzpicture}[auto, node distance = 1.5cm]
            \node (q0) [state, initial, initial text= ] {$q_0$};
            \node (q1) [state with output, above right = of q0] {$q_1$ \nodepart{lower} $0$};
            \node (q2) [state with output, below right = of q0] {$q_2$ \nodepart{lower} $0$};
            \node (q3) [state with output, right = of q1] {$q_3$ \nodepart{lower} $1$};
            \node (q4) [state with output, right = of q2] {$q_4$ \nodepart{lower} $0$};

            \path [-stealth, thick]
            (q0) edge node {$1$} (q1)
            (q0) edge node {$0$} (q2)
            (q1) edge [bend left] node {$0$} (q3)
            (q1) edge [bend left] node {$1$} (q4)
            (q2) edge node {$0$} (q4)
            (q2) edge [bend left] node {$1$} (q3)
            (q3) edge [bend left] node {$0$} (q2)
            (q3) edge node {$1$} (q1)
            (q4) edge [bend left] node {$0$} (q2)
            (q4) edge [bend left] node {$1$} (q1);
        \end{tikzpicture}
    \end{center}
\end{figure}

\section{Machines de Mealy}

\subsection{Définiton}

Une machine de Mealy est également un cas particulier de transducteur fini, moins restrictive à première vue que les machines de Moore.
Il s'agit d'un transducteur déterministe sans $\varepsilon$-transition.
\\~\\
Du point de vue du formalisme, elles sont définies de la même manière qu'un automate de Moore, à l'exception de la fonction de sortie
$\lambda$ qui est cette fois $\lambda : Q \times \Sigma \rightarrow \Gamma$. La fonction rationelle réalisée par une machine de Mealy
est définie de manière très similaire à celle pour les machines de Moore (il suffit juste de tenir comptre de la lettre de $\Sigma$ lue à chaque
étape du calcul)

\subsection{Equivalence avec Moore}

\subsection{Propriétés algébriques}

\end{flushleft}
\end{document}